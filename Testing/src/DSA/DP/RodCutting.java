package DSA.DP;
/*
Problem Statement:  Rod Cutting Problem

Problem Link: Rod Cutting Problem

We are given a rod of size ‘N’. It can be cut into pieces.
Each length of a piece has a particular price given by the price array.
Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.

Examples

Example:



 */

public class RodCutting {

    public static void main(String[] args) {
        int wt[] = { 2, 4, 6 };
        int val[] = { 5, 11, 13 };
        int W = 10;

        int n = wt.length;

        // Call the unboundedKnapsack function and print the result
        System.out.println("The Maximum value of items, the thief can steal is " + cutRod(n-1, W, val, wt));

        Integer[][] memo = new Integer[n][W+1];

        System.out.println("[Memo] The Maximum value of items, the thief can steal is " + cutRod(n-1, W, val, wt, memo));

        System.out.println("[DP] The Maximum value of items, the thief can steal is " + cutRodDP(n-1, W, val, wt));
        System.out.println("[DP Optimization] The Maximum value of items, the thief can steal is " + cutRodDPOpt(n-1, W, val, wt));

    }

    public static int cutRod(int n, int W, int[] val, int[] wt ) {

        if (W-wt[n] == 0)
            return val[n];

        if (n==0) {
            if (wt[0] <= W)
                return ((int)(W/wt[0])) * val[0];
        }

        int notTake = cutRod(n-1, W, val, wt);
        int take = 0;

        if (wt[n] <= W)
            take = val[n] + cutRod(n, W - wt[n], val, wt);

        return Math.max(take, notTake);
    }

    public static int cutRod(int n, int W, int[] val, int[] wt , Integer[][] dp) {

        if (W-wt[n] == 0)
            return val[n];

        if (n==0) {
            if (wt[0] <= W)
                return ((int)(W/wt[0])) * val[0];
        }

        if (dp[n][W] != null)
            return dp[n][W];

        int notTake = cutRod(n-1, W, val, wt);
        int take = 0;

        if (wt[n] <= W)
            take = val[n] + cutRod(n, W - wt[n], val, wt);

        dp[n][W] = Math.max(take, notTake);
        return Math.max(take, notTake);
    }

    public static int cutRodDP(int n, int W, int[] val, int[] wt) {
        int[][] dp = new int[n][W+1];

        for (int w = 0; w<=W; w++) {
            if (wt[0] <= w)
                dp[0][w] = ((int)(w/wt[0])) * val[0];
        }

        for (int i=1; i<n; i++) {
            for (int j = 0; j <= W; j++) {
                int notTake = dp[i-1] [j];
                int take = 0;

                if (wt[i] <= j)
                    take = val[i] + dp[i][ j - wt[i]];

                dp[i][j] =  Math.max(take, notTake);
            }
        }
        return dp[n-1][W];
    }

    public static int cutRodDPOpt(int n, int W, int[] val, int[] wt) {
        int[] prev = new int[W+1];

        for (int w = 0; w<=W; w++) {
            if (wt[0] <= w)
                prev[w] = ((int)(w/wt[0])) * val[0];
        }

        for (int i=1; i<n; i++) {
            for (int j = 0; j <= W; j++) {
                int notTake = prev [j];
                int take = 0;

                if (wt[i] <= j)
                    take = val[i] + prev[ j - wt[i]];

                prev[j] =  Math.max(take, notTake);
            }
        }
        return prev[W];
    }
}
